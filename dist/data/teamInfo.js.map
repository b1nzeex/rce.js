{"version":3,"file":"teamInfo.js","sourceRoot":"","sources":["../../src/data/teamInfo.ts"],"names":[],"mappings":"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","sourcesContent":["import { RegularExpressions } from \"./regularExpressions\";\nimport { ITeam, IPlayer } from \"../types\";\n\n/**\n * Parses the team info response from relationshipmanager.teaminfoall command\n * @param teamInfoResponse The raw response from the team info command\n * @param players List of currently connected players to filter out disconnected ones\n * @returns Object containing team list with player team references set\n */\nexport function parseTeamInfo(\n  teamInfoResponse: string,\n  players: IPlayer[] = []\n): {\n  teams: ITeam[];\n} {\n  const teams: ITeam[] = [];\n\n  if (\n    !teamInfoResponse ||\n    RegularExpressions.TeamInfoNoTeams.test(teamInfoResponse)\n  ) {\n    return { teams };\n  }\n\n  // Create a map of player names to Player objects for quick lookup\n  const playerMap = new Map<string, IPlayer>();\n  players.forEach((player) => {\n    playerMap.set(player.ign, player);\n  });\n\n  // Split the response into lines for processing\n  const lines = teamInfoResponse.split(\"\\n\").filter((line) => line.trim());\n\n  let currentTeamId: number | null = null;\n  let currentTeamMembers: IPlayer[] = [];\n  let currentTeamLeader: IPlayer | null = null;\n\n  for (const line of lines) {\n    // Check if this line is a team header\n    const teamHeaderMatch = line.match(RegularExpressions.TeamInfoTeamHeader);\n    if (teamHeaderMatch) {\n      // Save the previous team if we have one\n      if (currentTeamId !== null && currentTeamLeader !== null) {\n        if (currentTeamMembers.length > 0) {\n          const team: ITeam = {\n            id: currentTeamId,\n            leader: currentTeamLeader,\n            members: currentTeamMembers,\n          };\n\n          // Set team reference on all team members\n          currentTeamMembers.forEach((player) => {\n            player.team = team;\n          });\n\n          teams.push(team);\n        }\n      }\n\n      // Start new team\n      currentTeamId = parseInt(teamHeaderMatch[1]);\n      currentTeamMembers = [];\n      currentTeamLeader = null;\n      continue;\n    }\n\n    // Check if this line is a player entry\n    const playerMatch = line.match(RegularExpressions.TeamInfoPlayer);\n    if (playerMatch && currentTeamId !== null) {\n      const playerName = playerMatch[1].trim();\n      const player = playerMap.get(playerName);\n\n      // Only process connected players\n      if (player) {\n        currentTeamMembers.push(player);\n\n        // Check if this player is the leader\n        if (line.includes(\"(LEADER)\")) {\n          currentTeamLeader = player;\n        }\n      }\n    }\n  }\n\n  // Save the last team\n  if (currentTeamId !== null && currentTeamLeader !== null) {\n    if (currentTeamMembers.length > 0) {\n      const team: ITeam = {\n        id: currentTeamId,\n        leader: currentTeamLeader,\n        members: currentTeamMembers,\n      };\n\n      // Set team reference on all team members\n      currentTeamMembers.forEach((player) => {\n        player.team = team;\n      });\n\n      teams.push(team);\n    }\n  }\n\n  return { teams };\n}\n"]}
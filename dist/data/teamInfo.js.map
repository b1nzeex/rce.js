{"version":3,"file":"teamInfo.js","sourceRoot":"","sources":["../../src/data/teamInfo.ts"],"names":[],"mappings":"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","sourcesContent":["import { RegularExpressions } from \"./regularExpressions\";\r\nimport { Team, Player } from \"../types\";\r\n\r\n/**\r\n * Parses the team info response from relationshipmanager.teaminfoall command\r\n * @param teamInfoResponse The raw response from the team info command\r\n * @param players List of currently connected players to filter out disconnected ones\r\n * @returns Object containing team list with player team references set\r\n */\r\nexport function parseTeamInfo(teamInfoResponse: string, players: Player[] = []): {\r\n  teams: Team[];\r\n} {\r\n  const teams: Team[] = [];\r\n  \r\n  if (!teamInfoResponse || RegularExpressions.TeamInfoNoTeams.test(teamInfoResponse)) {\r\n    return { teams };\r\n  }\r\n\r\n  // Create a map of player names to Player objects for quick lookup\r\n  const playerMap = new Map<string, Player>();\r\n  players.forEach(player => {\r\n    playerMap.set(player.ign, player);\r\n  });\r\n\r\n  // Split the response into lines for processing\r\n  const lines = teamInfoResponse.split('\\n').filter(line => line.trim());\r\n  \r\n  let currentTeamId: number | null = null;\r\n  let currentTeamMembers: Player[] = [];\r\n  let currentTeamLeader: Player | null = null;\r\n  \r\n  for (const line of lines) {\r\n    // Check if this line is a team header\r\n    const teamHeaderMatch = line.match(RegularExpressions.TeamInfoTeamHeader);\r\n    if (teamHeaderMatch) {\r\n      // Save the previous team if we have one\r\n      if (currentTeamId !== null && currentTeamLeader !== null) {\r\n        if (currentTeamMembers.length > 0) {\r\n          const team: Team = {\r\n            id: currentTeamId,\r\n            leader: currentTeamLeader,\r\n            members: currentTeamMembers\r\n          };\r\n          \r\n          // Set team reference on all team members\r\n          currentTeamMembers.forEach(player => {\r\n            player.team = team;\r\n          });\r\n          \r\n          teams.push(team);\r\n        }\r\n      }\r\n      \r\n      // Start new team\r\n      currentTeamId = parseInt(teamHeaderMatch[1]);\r\n      currentTeamMembers = [];\r\n      currentTeamLeader = null;\r\n      continue;\r\n    }\r\n    \r\n    // Check if this line is a player entry\r\n    const playerMatch = line.match(RegularExpressions.TeamInfoPlayer);\r\n    if (playerMatch && currentTeamId !== null) {\r\n      const playerName = playerMatch[1].trim();\r\n      const player = playerMap.get(playerName);\r\n      \r\n      // Only process connected players\r\n      if (player) {\r\n        currentTeamMembers.push(player);\r\n        \r\n        // Check if this player is the leader\r\n        if (line.includes('(LEADER)')) {\r\n          currentTeamLeader = player;\r\n        }\r\n      }\r\n    }\r\n  }\r\n  \r\n  // Save the last team\r\n  if (currentTeamId !== null && currentTeamLeader !== null) {\r\n    if (currentTeamMembers.length > 0) {\r\n      const team: Team = {\r\n        id: currentTeamId,\r\n        leader: currentTeamLeader,\r\n        members: currentTeamMembers\r\n      };\r\n      \r\n      // Set team reference on all team members\r\n      currentTeamMembers.forEach(player => {\r\n        player.team = team;\r\n      });\r\n      \r\n      teams.push(team);\r\n    }\r\n  }\r\n  \r\n  return { teams };\r\n}\r\n"]}